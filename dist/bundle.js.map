{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/Background.js","webpack:///./js/Fish.js","webpack:///./js/Game.js","webpack:///./js/Obstacle.js","webpack:///./js/ObstacleGenerator.js","webpack:///./js/Score.js","webpack:///./js/main.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;;AAEA;;;;;;;;;;;;;ACnCA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;AClOA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI,IAAI,MAAM,IAAI,KAAK;AACzC;AACA;;;AAGA;;AAEA;;;;;;;;;;;;;;;AC/DA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;;;;;;;;;;;ACvCA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACtBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./js/main.js\");\n","class Background {\n\n  constructor(src, canvas, ctx) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n\n    this.x = 0;\n    this.y = 0;\n    this.height = this.canvas.height;\n    this.width = this.canvas.width;\n    this.src = src;\n    this.img = null\n\n    this.create.bind(this);\n    this.create();\n    this.draw.bind(this);\n  }\n\n  create() {\n    this.img = new Image();\n    this.img.src = this.src;\n  }\n\n  draw() {\n    if (this.img != null) {\n      // debugger\n      this.ctx.drawImage(this.img, this.x, this.y, this.width, this.height);\n    }\n  }\n\n\n\n\n}\n\nexport default Background;\n","class Fish {\n  constructor(src, canvas, ctx) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n\n    this.x = 115;\n    this.y = 115;\n    this.width = 115;\n    this.height = 90;\n\n    this.vy = 0;\n    this.g = 0.20;\n\n    this.src = src;\n    this.img = null;\n    this.frame = 0;\n\n    this.create = this.create.bind(this);\n    this.create();\n\n  }\n\n  create() {\n    this.img = new Image();\n    this.img.src = this.src;\n  }\n\n  draw() {\n    if (this.img != null) {\n      this.vy += this.g;\n      this.y += this.vy\n\n      if (this.y + this.height > this.canvas.height) {\n        this.y = this.canvas.height - this.height;\n        this.vy = 0;\n      } else if (this.y < 0) {\n        this.y = 0;\n        this.vy = 0;\n      }\n\n      this.ctx.drawImage(this.img, this.frame * 256, 0, 256, 175, this.x, this.y, this.width, this.height);\n      this.frame++;\n      this.frame %= 6\n      // debugger\n    }\n  }\n\n}\n\nexport default Fish;\n","import Background from './Background';\nimport Score from './Score';\nimport ObstacleGenerator from './ObstacleGenerator';\nimport Obstacle from './Obstacle';\nimport Fish from './Fish';\n\nclass Game {\n  constructor(canvas) {\n    this.canvas = canvas;\n    this.ctx = this.canvas.getContext('2d');\n\n    this.velocity = 5;\n    this.currentState = 1;\n    // console.log(this);\n    this.startGame = this.startGame.bind(this);\n    this.gameLoop = this.gameLoop.bind(this);\n    this.drawStartScreen = this.drawStartScreen.bind(this);\n    this.drawPlayingScreen = this.drawPlayingScreen.bind(this);\n    this.drawGameOverScreen = this.drawGameOverScreen.bind(this);\n    this.scrollBackground = this.scrollBackground.bind(this);\n    this.drawObstacles = this.drawObstacles.bind(this);\n    this.clearObstacles = this.clearObstacles.bind(this);\n    this.checkCollisions = this.checkCollisions.bind(this);\n    this.colliding = this.colliding.bind(this);\n    this.reset = this.reset.bind(this);\n\n\n    this.bindEvents = this.bindEvents.bind(this);\n    this.createObjects = this.createObjects.bind(this);\n    // this.background.create();\n    // this.bindEvents();\n    // this.createObjects();\n  }\n\n  createObjects() {\n    this.background1 = new Background('./images/background.png', this.canvas, this.ctx);\n    this.background2 = new Background('./images/background.png', this.canvas, this.ctx);\n    this.background2.x = this.canvas.width;\n\n    this.score = new Score(this.canvas, this.ctx);\n    this.score.x = this.canvas.width - 150;\n    this.score.y = 80;\n\n    this.obstacleGenerator = new ObstacleGenerator(this.canvas, this.ctx, './images/mine.png');\n\n    this.fish = new Fish('images/fish2.png', this.canvas, this.ctx);\n    // debugger\n  }\n\n  bindEvents() {\n    // debugger\n    document.addEventListener('keydown', (event) => {\n      // debugger\n      switch (this.currentState) {\n        case 3:\n        if (event.code === \"KeyR\") {\n          this.reset();\n          this.currentState = 2;\n        }\n        break;\n      }\n    });\n    document.addEventListener('click', (event) => {\n      switch (this.currentState) {\n        case 1:\n          this.currentState = 2;\n          this.obstacleGenerator.generate();\n          break;\n        case 2:\n          this.fish.vy = -1 * this.velocity;\n          break;\n        case 3:\n\n          break;\n      }\n\n    });\n\n  }\n\n  reset() {\n    this.score.start = new Date();\n    this.score.currentScore = 0;\n    this.obstacleGenerator.obstacles = [];\n    this.fish.x = 115;\n    this.fish.y = 115;\n  }\n\n  startGame() {\n\n    // requestAnimationFrame(this.gameLoop);\n    this.gameLoop();\n  }\n\n  gameLoop() {\n\n    switch (this.currentState) {\n      case 1:\n        this.drawStartScreen();\n        break;\n      case 2:\n        this.drawPlayingScreen();\n        break;\n      case 3:\n        this.drawGameOverScreen();\n        break;\n    }\n\n    requestAnimationFrame(this.gameLoop)\n  }\n\n  drawStartScreen() {\n    // game background\n    this.ctx.fillStyle = 'black';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.ctx.fillStyle = 'white';\n    this.ctx.font = '36px Arial';\n    this.ctx.fillText('START', this.canvas.width / 2 - 100, this.canvas.height / 2);\n\n  }\n\n  drawPlayingScreen() {\n    // debugger\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.scrollBackground();\n\n    this.score.draw();\n\n    this.drawObstacles();\n\n    this.fish.draw();\n\n    this.checkCollisions();\n\n  }\n\n  checkCollisions() {\n    this.obstacles = this.obstacleGenerator.obstacles;\n\n    for (var i = 0; i < this.obstacles.length; i++) {\n      if (this.colliding(this.fish, this.obstacles[i])) {\n        debugger\n        this.currentState = 3;\n      }\n    }\n  }\n\n  colliding(fish, obstacle) {\n    let colliding = true;\n\n    const fishTop = fish.y;\n    const fishBot = fish.y + fish.height;\n    const fishRight = fish.x + fish.width;\n    const fishLeft = fish.x;\n\n    const obstacleTop = obstacle.y + obstacle.space + obstacle.height;\n    const obstacleBot = obstacle.y + obstacle.height;\n    const obstacleRight = obstacle.x + obstacle.width;\n    const obstacleLeft = obstacle.x;\n\n    if ((fishBot < obstacleTop && fishTop > obstacleBot)\n      || (fishLeft > obstacleRight)\n      || (fishRight < obstacleLeft + 20)) {\n      colliding = false;\n    }\n\n    return colliding;\n  }\n\n  drawObstacles() {\n\n    this.obstacles = this.obstacleGenerator.obstacles;\n\n    for (let i = 0; i < this.obstacles.length; i++) {\n      // debugger\n      this.obstacles[i].draw();\n      this.obstacles[i].x -= this.velocity;\n    }\n\n    this.clearObstacles();\n  }\n\n  clearObstacles() {\n    this.obstacles = this.obstacleGenerator.obstacles;\n\n    for (let i = 0; i < this.obstacles.length; i++) {\n      if (this.obstacles[i].x + this.obstacles[i].width < 0) {\n        this.obstacles.shift();\n      }\n    }\n  }\n\n  scrollBackground() {\n    this.background1.draw();\n    if (Math.abs(this.background1.x) > this.canvas.width) {\n      this.background1.x = this.canvas.width - this.velocity;\n    }\n    this.background1.x = this.background1.x - this.velocity;\n\n    this.background2.draw();\n    if (Math.abs(this.background2.x) > this.canvas.width) {\n      this.background2.x = this.canvas.width - this.velocity;\n    }\n    this.background2.x = this.background2.x - this.velocity;\n\n  }\n\n  drawGameOverScreen() {\n    this.ctx.fillStyle = 'black';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    debugger\n    this.ctx.fillStyle = 'white';\n    this.ctx.font = '54px Arial';\n    this.ctx.fillText(`Score: ${this.score.score}`, this.canvas.width / 2 - 100, this.canvas.height / 2 - 180);\n    debugger\n    this.ctx.font = '36px Arial';\n    this.ctx.fillText('GAME OVER', this.canvas.width / 2 - 100, this.canvas.height / 2);\n    this.ctx.font = '24px Arial';\n    this.ctx.fillText('Press R to Restart', this.canvas.width / 2 - 100, this.canvas.height / 2 + 50);\n\n  }\n\n}\n\nexport default Game;\n","class Obstacle {\n  constructor(canvas, ctx, src) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n\n    this.x = this.canvas.width;\n    this.y = 0;\n    this.width = 100;\n    this.height = 0;\n    this.space = 0;\n\n    this.img = null;\n    this.src = src;\n\n\n    this.draw = this.draw.bind(this);\n    this.getRandomColor = this.getRandomColor.bind(this);\n    this.color = this.getRandomColor();\n    this.createImg = this.createImg.bind(this);\n    this.createImg();\n  }\n\n  createImg() {\n    this.img = new Image();\n    this.img.src = this.src;\n  }\n\n\n  draw() {\n    // debugger\n    if (this.img != null) {\n      // debugger\n      this.ctx.fillStyle = this.color;\n      this.ctx.fillRect(this.x, this.y, this.width, this.height);\n      // this.ctx.drawImage(this.img, this.x, this.y, this.width, this.height);\n      this.ctx.drawImage(this.img, this.x, this.height + this.space - 40, this.width, this.canvas.height);\n    }\n    // this.ctx.fillStyle = this.color;\n    //\n    // this.ctx.fillRect(this.x, this.y, this.width, this.height);\n    //\n    // this.ctx.fillRect(this.x, this.height + this.space, this.width, this.canvas.height);\n\n  }\n\n  getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return (Math.floor(Math.random() * (max - min)) + min);\n  }\n\n  getRandomColor() {\n    // debugger\n    const red = this.getRandomInt(0, 257);\n    const green = this.getRandomInt(0, 257);\n    const blue = this.getRandomInt(0, 257);\n    return `rgb(${red}, ${green}, ${blue})`;\n    // debugger\n  }\n\n\n}\n\nexport default Obstacle;\n","import Obstacle from './Obstacle';\n\nclass ObstacleGenerator {\n  constructor(canvas, ctx, src) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n\n    this.src = src;\n\n    this.minSpace = 200;\n    this.maxSpace = 300;\n    this.frequency = 1500;\n    this.obstacles = [];\n\n    this.generate = this.generate.bind(this);\n  }\n\n  generate() {\n    setInterval(() => {\n      let space = this.getRandomInt(this.minSpace, this.maxSpace);\n      let height = this.getRandomInt(0, this.maxSpace);\n\n      let obstacle = new Obstacle(this.canvas, this.ctx, this.src);\n      obstacle.space = space;\n      obstacle.height = height;\n\n      this.obstacles.push(obstacle);\n\n    }, this.frequency);\n  }\n\n  getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return (Math.floor(Math.random() * (max - min)) + min);\n  }\n\n\n}\nexport default ObstacleGenerator;\n","class Score{\n  constructor(canvas, ctx) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n\n    this.start = new Date();\n    this.currentScore = 0;\n    this.x = 0;\n    this.y = 0;\n\n    this.draw = this.draw.bind(this);\n  }\n\n  draw() {\n    const draw = new Date();\n    this.score = parseFloat((draw - this.start) / 1000).toFixed(1);\n\n    this.ctx.font = '45px Verdana';\n    this.ctx.fillText(this.score, this.x, this.y)\n  }\n}\n\nexport default Score;\n","import Game from './Game';\n\nwindow.onload = function() {\n\n  const canvas = document.getElementById('game');\n  const splashyFish = new Game(canvas);\n  splashyFish.startGame()\n  splashyFish.bindEvents();\n  splashyFish.createObjects();\n  // splashyFish.drawObstacles();\n};\n"],"sourceRoot":""}